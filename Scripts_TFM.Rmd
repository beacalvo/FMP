---
title: "Scripts_TFM"
author: "Beatriz Calvo"
date: "6/8/2019"
output: 
  word_document:
    highlight: pygments
  
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(eval = FALSE)

```


#Main code


Main code used throughout this project to obtain the results shown in the study report. The code can be in three different programming languages: Bash, Python and, mainly, R. The background colour of the code is indicative of the programmin language corresponding to that code.








##1. Code to summarize variant quality control results 

\


This script was used to count the number of variants excluded from the original dataset after the variant quality control, as well as to create some plots to compare the distribution of some parameters before and after the variant quality control. 

\



###1.1. Counting excluded variants

On the one hand, this script indicates, for each chromosome, the number of variants removed owing to each quality control filter:

* Variant call rate < 95%
* Variants not in HWE (P~HWE~ < 1.0x10^-06) 
* MAF < 1% 

Finally, the script summarizes the results per chromosome into a single summary file containing the results of all chromosomes.

NOTE: This script was first aimed at analyzing imputed genotype data. For this reason, this script also outputs the number of variants falling below an imputation accuracy (R^2^) threshold. In fact, three different minimum R^2^ thresholds were tested. The number of variants with an R^2^ below 0.25, 0.50 or 0.80 were reported, in order to help establish a definitive R^2^ cut-off.


###1.2. Summarizing performance of QC by creating plots

On the other hand, this script creates plots that allow to visually compare the distribution of some parameters before and after variant quality control. In this case, R^2^ and MAF before and after quality control are represented in histograms. Moreover, a plot correlating R^2^ and MAF is also obtained.


```{r, class.source="badCode"}

##############################################################################
################ R script to summarize results of variant QC #################
##############################################################################
#
# 25/02/2019
# Beatriz Calvo

##############################################################################
############ Counting the number of variants excluded during QC ##############

# Loading packages
library(data.table)

##############################################################################
# Start of the script
for (i in 1:22){
  
# Reading data for each chromosome (22 chromosomes in total) from the files 
# generated with vcftools and from ".info" file containing information about 
# the imputation accuracy
  
dataFreq <- fread(
  paste("~/data/WS_HELIX/HELIX_preproc/gwas/HRC_imp/QC_post_imp/MAF_filtering/freq_chr",
        i,".frq",sep=""))

dataInfo <- fread(
  paste("~/data/WS_HELIX/HELIX_preproc/gwas/HRC_imp/Final_data_Michigan/chr",
        i,".info",sep=""),data.table=F,stringsAsFactors = F)

dataHWE <- fread(
  paste("~/data/WS_HELIX/HELIX_preproc/gwas/HRC_imp/QC_post_imp/HWE_pvalue/hwe_chr",
        i,".hwe",sep=""),stringsAsFactors =F)

##############################################################################
# Editing "Freq" File

## Naming columns
names(dataFreq)[names(dataFreq)=="V1"] <- "CHR"
names(dataFreq)[names(dataFreq)=="CHROM"] <- "Pos"
names(dataFreq)[names(dataFreq)=="{ALLELE:FREQ}"] <- "Freq"

## Make dataframe of wanted columns
dataFreq <- data.frame(dataFreq$CHR,dataFreq$Pos,dataFreq$Freq)

## Calculate MAF from counts
ALT_ALLELE_FREQ <- as.numeric(
  (unlist(strsplit(as.character(dataFreq$dataFreq.Freq),
                   ":")))[c(FALSE,TRUE)])

ALT_ALLELE <- as.character(
  (unlist(strsplit(as.character(dataFreq$dataFreq.Freq),":")))[c(TRUE,FALSE)])

MAF <- ifelse(as.numeric(ALT_ALLELE_FREQ)>0.5,1-as.numeric(ALT_ALLELE_FREQ),
              as.numeric(ALT_ALLELE_FREQ))

## Make CHR:POS column
SNP <-as.character(paste(dataFreq$dataFreq.CHR,":",
                         dataFreq$dataFreq.Pos,sep=""))

## Store all information in dataframe
dataFreqClean <- data.frame(SNP,dataFreq$dataFreq.CHR,dataFreq$dataFreq.Pos,
                            ALT_ALLELE_FREQ,MAF,ALT_ALLELE)
dataFreqClean$SNP <- as.character(dataFreqClean$SNP)
colnames(dataFreqClean) <- c("SNP","CHR","POS","ALT_ALLELE_FREQ",
                             "MAF","ALT_ALLELE")

##############################################################################
# Editing "Info" File

## Make dataframe of wanted columns
dataInfoClean <- data.frame(dataInfo$SNP,dataInfo[,"REF(0)"],
                            dataInfo[,"ALT(1)"],dataInfo$Rsq,
                            dataInfo$Genotyped)
names(dataInfoClean)[names(dataInfoClean)=="dataInfo.SNP"] <- "SNP"
names(dataInfoClean)[names(dataInfoClean)=="dataInfo.Rsq"] <- "Rsq"

dataInfoClean$SNP <- as.character(dataInfoClean$SNP)
colnames(dataInfoClean) <- c("SNP","REF_ALLELE","ALT_ALLELE","Rsq","SOURCE")

##############################################################################
# Editing "HWE" File

## Make dataframe of wanted columns
SNP <- as.character(paste(dataHWE$CHR,":",dataHWE$POS,sep=""))

dataHWEClean <- data.frame(SNP,dataHWE$P_HWE)

##############################################################################
# Merging "Freq" and "Info" Files
dataMerge1 <- merge(dataInfoClean,dataFreqClean,by = c("SNP","ALT_ALLELE"))

##############################################################################
# Deleting multiallelic SNPs
dataMerge1sort <- dataMerge1[order(SNP),]

dataMerge2 <- data.frame(dataMerge1sort$SNP,dataMerge1sort$CHR,
                         dataMerge1sort$POS,dataMerge1sort$REF_ALLELE,
                         dataMerge1sort$ALT_ALLELE,
                         dataMerge1sort$ALT_ALLELE_FREQ,
                         dataMerge1sort$MAF,dataMerge1sort$Rsq,
                         dataMerge1sort$SOURCE)

colnames(dataMerge2)<- c("SNP","CHR","POS","REF_ALLELE","ALT_ALLELE",
                         "ALT_ALLELE_FREQ","MAF","Rsq","SOURCE")

toRemove <-names(which(table(dataMerge2$SNP)>1))

dataMerge1Clean <-dataMerge2[ !dataMerge2$SNP %in% toRemove ,  ]

dataHWEClean <- dataHWEClean[ !dataHWEClean$SNP %in% toRemove,]

##############################################################################
# Merging combined "Freq" & "Info" File with "HWE" File
dataTotal <- merge(dataMerge1Clean, dataHWEClean, by = "SNP")

colnames(dataTotal)<- c("SNP","CHR","POS","REF_ALLELE","ALT_ALLELE",
                        "ALT_ALLELE_FREQ","MAF","Rsq","SOURCE","HWE_PValue")

##############################################################################
# Filtering Files

## Setting Date
date <- Sys.Date()

dataMAF001_R2_0.25 <- dataTotal[(dataTotal$Rsq > 0.25) & 
                                  (dataTotal$MAF > 0.01) &
                                  (dataTotal$HWE_PValue > 10e-6),]

dataMAF001_R2_0.5 <- dataTotal[(dataTotal$Rsq > 0.5) &
                                 (dataTotal$MAF > 0.01) &
                                 (dataTotal$HWE_PValue > 10e-6),]

dataMAF001_R2_0.80 <- dataTotal[(dataTotal$Rsq > 0.80) &
                                  (dataTotal$MAF > 0.01) &
                                  (dataTotal$HWE_PValue > 10e-6),]

resume_table <- data.frame("Initial_variants" = dim(dataFreq)[1], 
                           "Multiallelic_SNPs"= length(toRemove) , 
                           "R2_0.25_included" = sum(dataTotal$Rsq > 0.25), 
                           "R2_0.25_excluded" = sum(dataTotal$Rsq <= 0.25), 
                           "R2_0.5_included" = sum(dataTotal$Rsq > 0.5), 
                           "R2_0.5_excluded" = sum(dataTotal$Rsq <= 0.5), 
                           "R2_0.80_included" = sum(dataTotal$Rsq > 0.80), 
                           "R2_0.80_excluded" = sum(dataTotal$Rsq <= 0.80), 
                           "MAF0.01_included" = sum(dataTotal$MAF > 0.01), 
                           "MAF0.01_excluded" = sum(dataTotal$MAF <= 0.01), 
                           "HWE_10e-6_included" = 
                             sum(dataTotal$HWE_PValue > 10e-6), 
                           "HWE_10e-6_excluded" = 
                             sum(dataTotal$HWE_PValue <= 10e-6), 
                           "Final_variantsR2_0.25" = 
                             dim(dataMAF001_R2_0.25)[1],
                           "Final_variantsR2_0.5" = dim(dataMAF001_R2_0.5)[1],
                           "Final_variantsR2_0.80" = 
                             dim(dataMAF001_R2_0.80)[1]
                           )


##############################################################################
# Creating a table for each chromosome with the number of variants that 
# are filtered and selected

write.table(
  resume_table,
  paste("~/data/WS_HELIX/HELIX_preproc/gwas/HRC_imp/QC_post_imp/post_imp_QC_BC/number_variantsR0.80",
        date,"_Chr",i,".txt",sep=""),quote=F,row.names=F,col.names=T)
}

##############################################################################
# Merging the information found in separate files for each chromosome 
# into a single file
total_initial <- 0
multiallelic_excluded <- 0
R2_0.5_excluded <- 0
R2_0.5_included <- 0
R2_0.25_excluded <- 0
R2_0.25_included <- 0
R2_0.80_excluded <- 0
R2_0.80_included <- 0
HWE_excluded <- 0
HWE_included <- 0
MAF_excluded <- 0
MAF_included <- 0
total_finalR2_0.25 <- 0
total_finalR2_0.5 <- 0
total_finalR2_0.80 <- 0

for (i in 1:22){
  x <- read.table(
    paste("~/data/WS_HELIX/HELIX_preproc/gwas/HRC_imp/QC_post_imp/post_imp_QC_BC/number_variantsR0.802019-03-02_Chr",
          i,".txt",sep=""), header = T)
  total_initial <- total_initial + x[1,1]
  multiallelic_excluded <- multiallelic_excluded + x[1,2]
  R2_0.25_included <- R2_0.25_included + x[1,3]
  R2_0.25_excluded <- R2_0.25_excluded + x[1,4]
  R2_0.5_included <- R2_0.5_included + x[1,5]
  R2_0.5_excluded <- R2_0.5_excluded + x[1,6]
  R2_0.80_included <- R2_0.80_included + x[1,7]
  R2_0.80_excluded <- R2_0.80_excluded + x[1,8]
  MAF_included <- MAF_included + x[1,9]
  MAF_excluded <- MAF_excluded + x[1,10]
  HWE_included <- HWE_included + x[1,11]
  HWE_excluded <- HWE_excluded + x[1,12]
  total_finalR2_0.25 <- total_finalR2_0.25 + x[1,13]
  total_finalR2_0.5 <- total_finalR2_0.5 + x[1,14]
  total_finalR2_0.80 <- total_finalR2_0.80 + x[1,15]
}

resume_all <- data.frame(total_initial, multiallelic_excluded, 
                         R2_0.25_included, R2_0.25_excluded, 
                         R2_0.5_included, R2_0.5_excluded, 
                         R2_0.80_included, R2_0.80_excluded, 
                         MAF_included, MAF_excluded, HWE_included, 
                         HWE_excluded, total_finalR2_0.25, 
                         total_finalR2_0.5, total_finalR2_0.80)

# Writing the file that contains all the summarized information
write.table(resume_all, 
            file = "~/data/WS_HELIX/HELIX_preproc/gwas/HRC_imp/QC_post_imp/post_imp_QC_BC/resume_all_differentR_withR0.80.txt",
            quote=F,row.names=F,col.names=T)



##############################################################################
###################### Creating plots of R2 and MAF ########################

# ---- Histogram of MAF

# Creating histogram of MAF before QC
pdf("hist_MAF_before_post_imputation_QC.pdf") 
hist(MAF, xlab = "MAF", col = "red", main ="Histogram MAF before post-imp QC")

# Storing the MAF values in a file for future uses
write.table(MAF, "MAF_before_post_imputation_QC.txt")

```

```{bash}
# Creating histogram of MAF after QC

## Creating file containing all SNPs selected after post-imputation QC
## and their MAF

cd ~/data/WS_HELIX/HELIX_preproc/gwas/HRC_imp/QC_post_imp

## Selecting the SNPs name and the MAFs columns
awk '{print $1, $7}' good_SNPs/QC_lowfreq_Michigan_rsq05_MAF001_INMA_2019-01-29_Chr*.txt > post_imp_QC_BC/MAF_All.txt

cd post_imp_QC_BC/
  
mv MAF_All.txt MAF_All_after_filtering0.01.txt

```

```{r}

## Histogram MAF after QC
maf_filtered <- read.table("MAF_All_after_filtering0.01.txt", 
                           header= T , sep = " ")
maf_numeric <- as.numeric(as.character(maf_filtered$MAF))
maf_numeric_NA <- maf_numeric[!is.na(maf_numeric)]

pdf("hist_MAF_after_post_imputation_QC.pdf")
hist(maf_numeric_NA, xlab = "MAF", col = "red", 
     main = "Histogram MAF after post-imp QC")

```

```{r}
# ---- Histogram of R2

# Joining all the values of R2 of all chromosomes into a single vector
library(data.table)
R2 <- NULL
for (i in 1:22){
  dataInfo <- fread(paste("~/data/WS_HELIX/HELIX_preproc/gwas/HRC_imp/Final_data_Michigan/chr",
                          i,".info",sep=""),
                    data.table=F,stringsAsFactors = F)
  R2 <- c(R2,dataInfo$Rsq)
}
pdf("hist_R2_accuracy_imputation.pdf")
hist(R2, xlab = "R2", col = "gray", main = "Histogram of the R2 accuracy of imputation")



# ---- Plot correlation MAF and R2

# Only 10000 values of MAF and R2 were used for the plot in order to see more
# clearly if there was any correlation
R2 <- NULL
MAF <- NULL
for (i in 1:22){
  dataInfo <- fread(paste("~/data/WS_HELIX/HELIX_preproc/gwas/HRC_imp/Final_data_Michigan/chr",
                          i,".info",sep=""),data.table=F,stringsAsFactors = F)
  R2 <- c(R2,dataInfo$Rsq)
  MAF <- c(MAF,dataInfo$MAF)
}
vec <- round(runif(10000, min =1,  max = length(MAF)))
png("plot_MAF_vs_R2.png")
plot(R2[vec],MAF[vec], main = "Plot of imputation accuracy (R2) vs MAF",
     xlab = "Imputation accuracy (R2)", ylab = "MAF", pch = 20)

```


\



##2. Code used for data processing

\


###2.1. Metabolomic data processing

The metabolomic data was contained in two different datasets: one fore serum and one for urine. In both cases, metabolite levels were contained in ExpressionSet objects. The *Minfi* package was used to manage this data (ref Minfi). This script was used to join both datasets and, once serum and urine metabolomic data had been merged, the resulting dataset was merged to the phenodata.



```{r}

##############################################################################
################### R script to process metabolomic data #####################
##############################################################################
#
# 19/03/2019
# Beatriz Calvo


# Loading packages
library(minfi)

# Loading the serum and urine datasets
load("/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_preproc/metabolome/Final_data/metab_urine_subcohort_v3.RData")
load("/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_preproc/metabolome/Final_data/metab_serum_subcohort_v3.RData")

# Extracting metabolites levels
exprs_urine <- exprs(metab_urine_subcohort)
exprs_serum <- exprs(metab_serum_subcohort) 


# Obtaining the transposed to have the samples ID as the row names
exprs_serum_t <- t(exprs_serum)
exprs_urine_t <- t(exprs_urine)

dim(exprs_serum_t) # 1208 samples and  177 metabolites
dim(exprs_urine_t) # 1211 samples and  44 metabolites


##############################################################################
# ---- Merging the two metabolite levels datasets
exprs <- merge(exprs_serum_t, exprs_urine_t, by = "row.names")
rownames(exprs) <- exprs$Row.names
exprs <- exprs[,-1]
dim(exprs) # 1202 samples and 221 metabolites


##############################################################################
# ---- Merging phenodata datasets of the serum and urine ExpressionSet objects
pdata_serum <- pData(metab_serum_subcohort)
pdata_urine <- pData(metab_urine_subcohort)

# Merging the phenodata of serum and urine based on the sample IDs
pdata <- merge(pdata_serum, pdata_urine, by = "row.names")

# The HelixIDs of the urine and serum samples match
identical(pdata$HelixID.ser, pdata$HelixID.uri)                                                                                                                                

# Counting samples with NAs in the HelixID column and removing them
sum(is.na(pdata$HelixID.ser)) # There are 2 NAs
pdata <- pdata[!is.na(pdata$HelixID.ser),]
dim(pdata)

# Deleting the "row.names" column created and assigning the HelixIDs as the 
# actual row names
rownames(pdata) <- pdata$HelixID.ser
pdata <- pdata[,-1]

# Deleting duplicated columns
pdata_final <- pdata[,!duplicated(t(pdata))]

##############################################################################
# ---- Merging the metabolomic data with the phenodata of individuals
exprs_helixID <- merge(exprs, pdata_final, by = "row.names")

# Setting helixIDs as rownames
row.names(exprs_helixID) <- exprs_helixID$HelixID.ser 

# Removing the SampleID and HelixID columns
exprs_helixID <- exprs_helixID[,c(-1,-223,-224)] 

write.csv(exprs_helixID, "expression_serum_urine_helixID.csv")
save(exprs_helixID, file = "expression_serum_urine_helixID.RData")



```



Moreover, metabolites names were changed to the reference names. Common metabolites in serum and urine were addressed by adding to each metabolite name the extension ".serum" and ".urine" to serum and urine metabolites, respectively.

```{r}
##############################################################################
# Obtaining reference names for metabolites
p.urine <- pData(featureData(metab_urine_subcohort))

p.serum <- pData(featureData(metab_serum_subcohort))

# Common metabolites in serum and urine
common_chebi <- intersect(p.serum$CHEBI,p.urine$CHEBI) 

common_serum <- p.serum[p.serum$CHEBI%in%common_chebi,]
common_urine <- p.urine[p.urine$CHEBI%in%common_chebi,]

#The common metabolites in serum and urine with equal CHEBI number but
# different reference nomenclature are mostly aminoacids, which are 
# abbreviated (e.g. Lys) in serum but not in urine (e.g. Lysine)


##############################################################################
# --- SERUM
identical(p.serum$Rvar.log, names(exprs_helixID)[1:177]) # TRUE

# Same order in annotation file than in expression file, so we can assign
# the reference metabolite names by:
names(exprs_helixID)[1:177] <- p.serum$Rvar

# Position of the common metabolites according to CHEBI ID in serum
common_serum_pos <- which(names(exprs_helixID)[1:177]%in%common_serum$Rvar) 

identical(names(exprs_helixID)[common_serum_pos],common_serum$Rvar) # TRUE

## NOTE: The metabolites names that are going to be used are the ones in urine  
## which are not abbreviated

# Ordering the urine names following the order of appearance in serum
common_serum_ordered <- common_urine[match(common_serum$CHEBI, 
                                           common_urine$CHEBI),]  

# Assigning the metabolite names to the common metabolites
names(exprs_helixID)[common_serum_pos] <- common_serum_ordered$Rvar

#Adding ".serum" to all serum metabolites
names(exprs_helixID)[1:177] <- paste(names(exprs_helixID)[1:177], ".serum", 
                                     sep = "")


##############################################################################
# ---- URINE

identical(names(exprs_helixID)[178:221], p.urine$Rvar)
# TRUE: urine metabolites already in the reference nomenclature

# Only the ".urine" suffixe has to be added:

names(exprs_helixID)[178:221] <- paste(names(exprs_helixID)[178:221],
                                       ".urine", sep = "")

#Saving file
save(exprs_helixID, file = "expression_helixID_metabolites_names_OK.RData")


```

\


Next, metabolite ratios were computed from the 44 urine metabolites.

```{r}
##############################################################################
# ---- Computing urine metabolite ratios
c <- 1
p <- 1
name <- NULL
df <- matrix(nrow = 996,ncol = 946)
for (i in 178:220) {
  for (j in (c+178):221) {
    ratio <- exprs_helixID[,i]-exprs_helixID[,j]
    df[,p] <- ratio
    name[p] <- paste(colnames(exprs_helixID)[i], 
                     colnames(exprs_helixID)[j], 
                     sep ="_")
    p <- p + 1
  }
  c <- c + 1
}
colnames(df) <- name

exprs_helixID_ratios <- data.frame(exprs_helixID, df)
write.table(exprs_helixID_ratios, "phenotypes_urine_PCs_plus_ratios.txt",
            sep = "\t", quote =FALSE, row.names = FALSE)


```


\


###2.2. Metadata data processing

As mentioned in the methodology in Section 3.4., the metadata was used to identify those individuals for which the ancestry predicted by the *Peddy* program was not European. Then, these individuals were removed from the dataset. This way, the final dataset contained metadata, serum and urine metabolite levels, as well as urine ratios, of the 996 individuals with European predicted ancestry.


```{r}
##############################################################################
# ---- Selecting only individuals with European predicted ancestry
exprs_helixID_ratios_EUR <- exprs_helixID_ratios[exprs_helixID_ratios$
                                                   FINAL_ancestry=="EUR",]
dim(exprs_helixID_ratios_EUR)

```

\


###2.3. Genotype data processing

The genotype data was already in PLINK binary format (ref PLINK). However, it contained variants located in the mitochondrial DNA and in the non-canonical PAR region of chromosome Y. These variants were excluded from further analysis. To do so, the following script was used.

```{bash}
##############################################################################
# This command is used to change the codification of the sexual chromosomes 
# and mitochondrial DNA from the chrX, chrY and MT nomenclature to the
# numerical nomenlcature in PLINK (23, 24 and 26, respectively)

plink --bfile /home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_preproc/gwas/Final_data/v2/HELIX_GWAS_FINAL  --make-bed --out HELIX_GWAS_FINAL_genotyped

# Moving the variants located in the PAR1 and PAR2 regions to a different
# chromosome (chromosome number 25 in PLINK)
plink --bfile HELIX_GWAS_FINAL_genotyped --split-x 'hg19' --make-bed --out HELIX_GWAS_FINAL_genotyped_XYchr


# Removing variants located in mitochondrial DNA and in the non-canonical PAR region of chromosome Y
plink --bfile HELIX_GWAS_FINAL_genotyped_XYchr --make-bed --not-chr 24,26 --out HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT


```


It was checked that genotyped variants in chromosome X were coded as 0 or 2 in males (representing a single copy of the X chromosome), whereas females variants in chromosome X were coded as 0, 1 or 2 (owing to the pair of X chromosomes). Instead, for the PAR regions (chromosome 25 in PLINK), both males and females variants were coded as diploid (0, 1 or 2).

\



##3. Preparing input data for CMS method


\

The CMS scripts required the input data to be in a specific format, as well as the creation of other files with information of our data.

\



###3.1. Code to prepare genotype data for statistical analysis


\

Three datasets of genotype data were needed since three different statistical analysis were carried out (positive control, negative control and whole-genome analysis).

\




####3.1.1. Preparing genotype data for whole-genome analysis


*Script 2* required the genotype data to be recoded from the binary PLINK format to the `.raw` file, in order to use the `.raw` file as input. In this format genotypes are coded as a single allele dosage number (additive coding), which represents the number of minor alleles per person.


```{bash}
##############################################################################
# Recoding the genotype data from the binary format to the .raw format

plink --bfile HELIX_GWAS_FINAL_genotyped_XYchr --recodeA --not-chr 24,26 --maf 0.05 --out HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05 # MAF 0.05


```

\

*Script 3* requires the `BIM` file as input, in order to include SNP-related information (chromosome, variant identifier, position, base-pair coordinate, allele 1 and allele 2) to the summary tables. In order for the MAF to be included in these tables, the `BIM` file was modified by adding a column containing the MAF for each SNP.


```{bash}
# Obtaining the BIM file
plink --bfile HELIX_GWAS_FINAL_genotyped_XYchr --make-bed --not-chr 24,26 --maf 0.05 --out HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05

# Obtaining the FRQ file, which contains the MAF values
plink --bfile HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05 --freq --out HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05

```

```{r}
# Modifying the BIM file in order to add the MAF
maf <- read.table("HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05.frq", header=TRUE)
maf_col <- maf$MAF
write.table(maf_col, file ="maf_column_MAF0.05.txt", row.names = FALSE, col.names = FALSE) 

```

```{bash}

paste HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05.bim maf_column_MAF0.05.txt > HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05_MAF.bim

```

\



####3.1.2. Preparing genotype data for positive and negative controls


The genotype data located in each of the two regions analysed (FADS and AGXT2 loci) was extracted from the initial dataset. Next, the same files as the ones obtained in the previous section were created.


* FADS locus

```{bash}
##############################################################################
# Recoding the genotype data from the binary format to the .raw format and 
# obtaining the FRQ file
plink --bfile HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05 --from-kb 61300 --to-kb 61800  --chr 11 --recodeA --freq --out HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05_FADS

# Obtaining the BIM file
plink --bfile HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05 --from-kb 61300 --to-kb 61800  --chr 11 --make-bed --out HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05_FADS

```

```{r}
# Modifying the BIM file in order to add the MAF
maf <- read.table("HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05_FADS.frq", header=TRUE)
maf_col <- maf$MAF
write.table(maf_col, file ="maf_column_MAF0.05_FADS.txt", row.names = FALSE, col.names = FALSE) 


```


```{bash}

paste HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05_FADS.bim maf_column_MAF0.05_FADS.txt > HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05_FADS_MAF.bim

```



* AGXT2 locus



```{bash}
##############################################################################
# Recoding the genotype data from the binary format to the .raw format and 
# obtaining the FRQ file
plink --bfile HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05 --from-kb 34800 --to-kb 35200  --chr 5 --recodeA --freq --out HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05_AGXT2

# Obtaining the BIM file
plink --bfile HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05 --from-kb 34800 --to-kb 35200  --chr 5 --make-bed --out HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05_AGXT2

```

```{r}
# Modifying the BIM file in order to add the MAF
maf <- read.table("HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05_AGXT2.frq", header=TRUE)
maf_col <- maf$MAF
write.table(maf_col, file ="maf_column_MAF0.05_AGXT2.txt", row.names = FALSE, col.names = FALSE) 


```


```{bash}

paste HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05_AGXT2.bim maf_column_MAF0.05_AGXT2.txt > HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05_AGXT2_MAF.bim

```



\



###3.2. Code to prepare phenotype data for statistical analysis


The `phenotypes_file.txt` required as input in *Script 1*  was a text file, with columns separated by tabulations and a header line. It contained one line per individual and the first column was the individual ID. This file contained both confounding variables and serum and urine metabolite levels. The runCMS code did not allow categorical variables (i.e. sex and urine sampling type), so the categorical variables in the metadata were transformed to dummy variables. The following script shows how the sex and urine sampling type variables were transformed to dummy variables and, finally, the `phenotypes_file.txt` used as input in *Script 1* is created. The `fastDummies` (ref) package was used.


```{r}

##############################################################################
########### Script to prepare the data for the runCMS analysis ###############
##############################################################################
#
# 30/04/2019
# Beatriz Calvo

##############################################################################
# ---- Dummy variables

# Loading packages
library(fastDummies)

# Creating dummy variables from sex variable
dummy_sex <- dummy_columns(pdata_final_metadata_EUR$e3_sex.ser)
dummy_sex <- dummy_sex[,2]

# Creating dummy variables from sampling type variable
dummy_sample_type <- dummy_columns(pdata_final_metadata_EUR$Urine.SamplingType.uri)
dummy_sample_type <- dummy_sample_type[,2:3]

# Adding the dummy variables
pdata_final_metadata_EUR_dummy <- pdata_final_metadata_EUR
pdata_final_metadata_EUR_dummy$e3_sex.ser <- dummy_sex
colnames(pdata_final_metadata_EUR_dummy)[10] <- "sex.data_male"

colnames(dummy_sample_type) <- paste("sample_type", 
                                     colnames(dummy_sample_type), sep ="")

pdata_final_metadata_EUR_dummy <- cbind(pdata_final_metadata_EUR_dummy[,1:29], 
                                        dummy_sample_type, 
                                        pdata_final_metadata_EUR_dummy[,31:58])



# Testing individuals are in the same order in metadata and in expression data

identical(rownames(pdata_final_metadata_EUR_dummy),
          rownames(exprs_helixID_ordered)) #TRUE


# Obtaining "phenotypes file"
pdata_final_metadata_EUR_dummy_urine <- cbind("HelixID.ser" = 
                                                pdata_final_metadata_EUR$HelixID.ser, 
                                              "sex.data_male" = 
                                                pdata_final_metadata_EUR_dummy$sex.data_male,
                                              "age_sample_years" = 
                                                pdata_final_metadata_EUR_dummy$age_sample_years.ser, 
                                              dummy_sample_type, 
                                              pdata_final_metadata_EUR[,30:49])  

pdata_final_metadata_EUR_dummy_urine$HelixID.ser <- as.character(
  pdata_final_metadata_EUR_dummy_urine$HelixID.ser)


identical(pdata_final_metadata_EUR_dummy_urine$HelixID.ser, 
          rownames(exprs_helixID_ordered))  # TRUE: Same Helix_ID order

# Joining metabolites level data to the metadata: PHENOTYPES file

phenotypes_file_urine <- cbind(pdata_final_metadata_EUR_dummy_urine, 
                               exprs_helixID_ordered)


write.table(phenotypes_file_urine, "phenotypes_urine.txt", sep = "\t", quote =FALSE, row.names = FALSE)

# Saving workspace
save.image(file = "dummy_and_phenotypes_file_workspace.RData")


```
\



###3.3. Code to create other input files required to run CMS


The runCMS code required the creation of another file as input of *Scripts 1*, *2* and *3*, called `summary_file.csv`. This is a `.csv` file with columns separated by commas and a header line. This file aims at describing the role of each variable contained in the phenotypes file. For each selected variable, a label and a binary indicator for classification as confounding factors (i.e. variables systematically included as covariates), outcome (i.e. each single variable that will be treated as a primary outcome) and candidate covariates (i.e. variables that will be assessed by CMS for inclusion as a covariate) are provided. By default, all variables in "Covariates" column are included as covariates in each outcome analysis. However, the "Excluded" column can be used to exclude specific variables from being considered as covariates for a given outcome. In our study, we excluded the covariates that were hierarchical parent of the outcome under study or vice versa, in order to reduce bias. For example, "X3.aminoisobutyrate.urine" was excluded from being a possible covariate of "X3.hydroxybutyrate.3.aminoisobutyrate.urine" and vice versa, since "X3.hydroxybutyrate.3.aminoisobutyrate.urine" represents the concentrations of both "X3.aminoisobutyrate.urine" and "3.hydroxybutyrate" (i.e. the metabolite "X3.hydroxybutyrate.3.aminoisobutyrate.urine" is a hierarchical parent of "X3.aminoisobutyrate.urine", this is why both metabolites are excluded as possible covariates of the other metabolite).
Moreover, for the urine metabolites that were also measured in serum, the corresponding serum metabolite was added to the "Excluded" column, since there is a strong possibility that they share some source of variability.



```{r}
##############################################################################
# ---- Creating Phenotypes summary file for urine

phenotypes_summary_urine <- as.data.frame(matrix(0, ncol = 5,
                                                 nrow =  dim(phenotypes_file_urine)[2]))

colnames(phenotypes_summary_urine) <- c("Label", "Conf", "Outcome", 
                                        "Covariate", "Excluded")

phenotypes_summary_urine$Label <- colnames(phenotypes_file_urine)

# Confusing variables
phenotypes_summary_urine$Conf[1:24] <- 1

# Outcome variables
phenotypes_summary_urine$Outcome[202:245] <- 1

# Covariate variables
phenotypes_summary_urine$Covariate[25:245] <- 1

# Adding the "Excluded" metabolites: for metabolites found both in serum and 
# in urine, the metabolite in urine or serum, respectively, is excluded (not 
# considered as a possible covariate)

phenotypes_summary_urine$Excluded <- ""

metabolites_names <- c(gsub(".serum", "", phenotypes_summary_urine$Label[25:201]), 
                       gsub(".urine", "", phenotypes_summary_urine$Label[202:245]))

common_metab <- metabolites_names[duplicated(metabolites_names)]

for (i in common_metab) {
  position <- which(phenotypes_summary_urine$Label == paste(common_metab,
                                                            "urine", sep ="."))
  
  phenotypes_summary_urine[position, "Excluded"] <- paste(common_metab, 
                                                          "serum", sep =".") 
}

# Excluding "X3.aminoisobutyrate.urine" from being a possible covariate of 
# "X3.hydroxybutyrate.3.aminoisobutyrate.urine" and vice versa, since 
# "X3.hydroxybutyrate.3.aminoisobutyrate.urine" represents the concentrations 
# of both "X3.aminoisobutyrate.urine" and "3.hydroxybutyrate"

position <- which(phenotypes_summary_urine$Label == "X3.aminoisobutyrate.urine")
phenotypes_summary_urine[position, "Excluded"] <- 
  "X3.hydroxybutyrate.3.aminoisobutyrate.urine" 

position <- which(phenotypes_summary_urine$Label == 
                    "X3.hydroxybutyrate.3.aminoisobutyrate.urine")
phenotypes_summary_urine[position, "Excluded"] <- "X3.aminoisobutyrate.urine"


write.csv(phenotypes_summary_urine, file = "summary_urine.csv", 
          row.names = FALSE, quote = FALSE)

save(phenotypes_summary_urine, file = "summary_urine.RData")



```


\




##4. Computing heritability

SNP heritability was computed using genome-wide complex trait analysis (GCTA), which estimates the additive contribution to a trait's heritability of a particular subset of SNPs (GREML analysis) (ref). GCTA is a command-line tool with options similar to the commonly used PLINK software. Only autosomal SNPs and SNPs with MAF > 0.01 were considered to build the GRM.

First, the input files needed for the analysis were created.

```{r}
##############################################################################
############################## GCTA analysis #################################
##############################################################################

##############################################################################
# ---- Input files to run GCTA analysis

fam <- read.table("HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT.fam", 
                  sep = " ")
head(fam)
id <- fam[,1:2]

load("dummy_and_phenotypes_file_workspace.RData")

colnames(id) <- c("fam_id","ID") 

all <- merge(phenotypes_file_urine_plus_ratios, id, 
             by.x="HelixID.ser", by.y="ID")

all_ordered <- all[match(id$ID, 
                         phenotypes_file_urine_plus_ratios$HelixID.ser),]

match(id$ID, phenotypes_file_urine_plus_ratios$HelixID.ser)[
  !is.na(match(id$ID,phenotypes_file_urine_plus_ratios$HelixID.ser))]

all_ordered <- all[order,]

id_keep <- all_ordered[,c(2,1)] 
ID <- id_keep$ID
fam_id <- id_keep$fam_id

id_keep[,1] <- fam_id
id_keep[,2] <- as.character(ID)

write.table(id_keep, file = "ID_to_keep.txt", sep = "\t", quote=FALSE,
            row.names = FALSE, col.names = FALSE)

save.image("files_gtca.RData")
```

```{bash}
# Creating PLINK files of only the 996 individuals for which there is 
# phenotypic information
plink --bfile ../HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT \
--keep ID_to_keep.txt --make-bed \
--out HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_996_individuals
```

```{r}

load("files_gtca.RData")
identical(as.character(all_ordered$ID),as.character(plink$V2))
all_ordered[,1] <- all_ordered[,2] 
all_ordered$fam_id <- ID   
colnames(all_ordered)[1:2] <- c("FIID","ID")

# File containing the phenotypes (metabolite levels)
pheno_file <- all_ordered[,c(1:2,204:247)]
write.table(pheno_file, file = "urine.phen", quote=FALSE, 
            row.names=FALSE, col.names=FALSE, sep = "\t")

# Covar: file containing categorical variables (sex and sample type)
covar_file <- all_ordered[,c(1:3,5:6)]
write.table(covar_file, file = "urine.covar", quote=FALSE, 
            row.names=FALSE, col.names=FALSE, sep = "\t")

# Qcovar: file containing quantitive variables (age and 20 PCs)
qcovar_file <- all_ordered[,c(1:2,4,7:26)]
write.table(qcovar_file, file = "urine.qcovar", quote=FALSE, 
            row.names=FALSE, col.names=FALSE, sep = "\t")

save.image("files_gtca.RData")

```


\

Next, the GRM was computed by GCTA and GCTA-GREML analysis was carried out.

```{bash}
##############################################################################
# ---- GCTA-GRM: calculating the genetic relationship matrix (GRM) from all 
#      the autosomal SNPs
gcta64 --bfile files_gcta/HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_996_individuals \
--autosome --maf 0.05 \
--make-grm --out HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_996_individuals \
--thread-num 10


# ---- GCTA-GREML analysis: estimating the variance explained by the SNPs

# Loop running GCTA-GREML for the 44 urine metabolites
for i in {1..44}
do gcta64 \
--grm HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_996_individuals \
--pheno urine.phen --mpheno $i \
--covar urine.covar \
--qcovar urine.qcovar --reml \
--out HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_996_individuals_$i \
--thread-num 10
done


```
\


Finally, SNP-heritability results were summarized. Moreover, results were plotted in two circular plots. One represented variation from additive genetic effects (V(G)), variation from residual effects V(e) and the total phenotypic variation (Vp); while the other one showed the proportion of genotypic to phenotypic variation (V(G)/Vp). In order to create the plots, the R packages from CRAN *tidyverse* (ref), *viridis* (ref) and *ggplot2* (ref) were used.

```{r}
##############################################################################
# ---- Summarizing GCTA results in a table

load("files_gtca.RData")
heritability <- matrix(nrow = 44, ncol = 14)
rownames(heritability) <- colnames(pheno_file)[c(3:46)]
colnames(heritability) <- c("V(G)","V(G)_SE","V(e)","V(e)_SE","Vp","Vp_SE",
                            "V(G)/Vp", "V(G)/Vp_SE","logL","logL0","LTR",
                            "df","Pval","n")
for (i in 1:44) {
  output <- read.table(
    paste("HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_996_individuals_",
          i,".hsq", sep = ""),
    fill = TRUE,header = T)
  for (j in 1:14) {
      heritability[i,j] <- round(output[1,j+1], digits = 3)
  }
}

# Single urine metabolites
write.table(heritability, 
            file ="summary_heritability_results_by_metabolite.txt",
            sep = "\t", quote = F)

```
\


```{r}

##############################################################################
# ---- Creating circular plot 1

# Loading library
library(tidyverse)
library(viridis)

# Obtaining metabolites for which the likelihood ratio test is
# significant (p-value < 0.05)
sign <- ifelse(heritability[,13] < 0.05, "P-value < 0.05", "P-value > 0.05")

# Introducing line breaks to make metabolite names labels shorter
row.names(heritability)[28] <- "X3.hydroxybutyrate-\n3.aminoisobutyrate"
row.names(heritability)[38] <- "N.methyl-\n2.pyridone-\n5.carboxamide"
row.names(heritability)[30] <- "N.acetyl-\nneuraminic.acid"
row.names(heritability)[34] <- "Proline.\nbetaine"
row.names(heritability)[42] <- "N.methylpicolinic.\nacid"

# Create dataset
data <- data.frame(
  individual=gsub(".urine", "", row.names(heritability), fixed = T),
  group=sign,
  heritability[,c(1,3,5)]
)

row.names(data) <- NULL

# Transform data in a tidy format (long format)
data <- data %>% gather(key = "observation", value="value", -c(1,2)) 

# Setting a number of 'empty bar' to add at the end of each group
empty_bar <- 2
nObsType <- nlevels(as.factor(data$observation))
to_add <- data.frame( matrix(NA, empty_bar*nlevels(data$group)*nObsType,
                             ncol(data)) )
colnames(to_add) <- colnames(data)
to_add$group <- rep(levels(data$group), each=empty_bar*nObsType )
data <- rbind(data, to_add)
data <- data %>% arrange(group, individual)
data$id <- rep( seq(1, nrow(data)/nObsType) , each=nObsType)

# Getting the name and the y position of each label
label_data <- data %>% group_by(id, individual) %>% summarize(tot=sum(value))
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5) /number_of_bar     
label_data$hjust <- ifelse( angle < -90, 1, 0)
label_data$angle <- ifelse(angle < -90, angle+180, angle)

# Preparing a data frame for base lines
base_data <- data %>% 
  group_by(group) %>% 
  summarize(start=min(id), end=max(id) - empty_bar) %>% 
  rowwise() %>% 
  mutate(title=mean(c(start, end)))

# Preparing a data frame for grid (scales)
grid_data <- base_data
grid_data$end <- grid_data$end[ c( nrow(grid_data), 1:nrow(grid_data)-1)] + 1
grid_data$start <- grid_data$start - 1
grid_data <- grid_data[-1,]

# Making the plot
p <- ggplot(data) +      
  
  # Adding the stacked bar
  geom_bar(aes(x=as.factor(id), y=value, fill=observation), 
           stat="identity", alpha=0.5) +
  scale_fill_viridis(discrete=TRUE) +
  

  ylim(-10,max(label_data$tot, na.rm=T)) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    plot.margin = unit(rep(-1,4), "cm")
  ) +
  coord_polar() +

  # Adding labels on top of each bar
  geom_text(data=label_data, aes(x=id, y=tot+1, label=individual,hjust=hjust),
            color="black", fontface="bold",alpha=0.9, size=6, 
            angle= label_data$angle, inherit.aes = FALSE ) +
  
  # Adding base line information
  geom_segment(data=base_data, aes(x = start, y = -1, xend = end, yend = -1),
               colour = "black", alpha=0.8, size=0.6 , inherit.aes = FALSE ) +
  geom_text(data=base_data, aes(x = title, y = -5, label=group), hjust=c(1,0),
            colour = "black", alpha=0.8, size=8, fontface="bold", 
            inherit.aes = FALSE)


# Save at png
ggsave(p, file="circular_plot_heritability_variation.png", width=20, height=20)



##############################################################################
# ---- Creating circular plot 2 (just heritability)

# Changing metabolite names

row.names(heritability)[28] <- "3-hydroxybutyrate-\n3-aminoisobutyrate"
row.names(heritability)[38] <- "N-methyl-2-pyridone-\n5-carboxamide"
row.names(heritability)[39] <- "p-hydroxy-\nphenylacetate"
row.names(heritability)[30] <- "N-acetyl-\nneuraminic acid"
row.names(heritability)[34] <- "Proline\nbetaine"
row.names(heritability)[42] <- "N-methylpicolinic\nacid"

names <- gsub("X", "", row.names(heritability))
names <- gsub(".acid", " acid", names, fixed = T)
names <- gsub(".", "-", names, fixed = T)

# Loading libraries
library(tidyverse)

# Creating dataset

data <- data.frame(
  individual=gsub("-urine", "", names, fixed = T),
  group=sign,
  value = heritability[,c(7)]
)
row.names(data) <- NULL

# Setting a number of 'empty bar' to add at the end of each group
empty_bar <- 3
to_add <- data.frame( matrix(NA, empty_bar*nlevels(data$group), ncol(data)))
colnames(to_add) <- colnames(data)
to_add$group <- rep(levels(data$group), each=empty_bar)
data <- rbind(data, to_add)
data <- data %>% arrange(group)
data$id <- seq(1, nrow(data))

# Getting the name and the y position of each label
label_data <- data
number_of_bar <- nrow(label_data)
angle <- 90 - 360 * (label_data$id-0.5) /number_of_bar
label_data$hjust <- ifelse( angle < -90, 1, 0)
label_data$angle <- ifelse(angle < -90, angle+180, angle)

# Preparing a data frame for base lines
base_data <- data %>% 
  group_by(group) %>% 
  summarize(start=min(id), end=max(id) - empty_bar) %>% 
  rowwise() %>% 
  mutate(title=mean(c(start, end)))

# Preparing a data frame for grid (scales)
grid_data <- base_data
grid_data$end <- grid_data$end[ c( nrow(grid_data), 1:nrow(grid_data)-1)] + 1
grid_data$start <- grid_data$start - 1
grid_data <- grid_data[-1,]

# Making the plot
p <- ggplot(data, aes(x=as.factor(id), y=value, fill=group)) +
  
  geom_bar(aes(x=as.factor(id), y=value, fill=group), 
           stat="identity", alpha=0.5) +
  
   # Add a val=100/75/50/25 lines.
  geom_segment(data=grid_data, aes(x = 48, y = 0.80, xend = 1, yend = 0.80),
               colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = 48, y = 0.60, xend = 1, yend = 0.60),
               colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = 48, y = 0.40, xend = 1, yend = 0.40),
               colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  geom_segment(data=grid_data, aes(x = 48, y = 0.20, xend = 1, yend = 0.20),
               colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
    geom_segment(data=grid_data, aes(x = 48, y = 1, xend = 1, yend = 1),
               colour = "grey", alpha=1, size=0.3 , inherit.aes = FALSE ) +
  
   # Add text showing the value of each 100/75/50/25 lines
  annotate("text", x = rep(max(data$id),5), y = c(0.20, 0.40, 0.60, 0.80,1), 
           label = c("0.2", "0.4", "0.6", "0.8","1") , color="grey", size=6 ,
           angle=0, fontface="bold", hjust=1) +
  
  geom_bar(aes(x=as.factor(id), y=value, fill=group), 
           stat="identity", alpha=1) +
  ylim(-0.75,2) +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.text = element_blank(),
    axis.title = element_blank(),
    panel.grid = element_blank(),
    plot.margin = unit(rep(-1,4), "cm") 
  ) +
  coord_polar() + 
  geom_text(data=label_data, aes(x=id, y=value+0.1, label=individual, 
                                 hjust=hjust), 
            color="black", fontface="bold",alpha=0.9, size=6, 
            angle= label_data$angle, inherit.aes = FALSE ) +
  
  # Add base line information
  geom_segment(data=base_data, aes(x = start, y = -0.1, xend = end, 
                                   yend = -0.1), colour = "black", 
               alpha=0.8, size=0.8 , inherit.aes = FALSE )  +
  geom_text(data=base_data, aes(x = title+1, y = -0.2, label=group),
            hjust=c(1,0), colour = "black", alpha=0.8, size=7, 
            fontface="bold", inherit.aes = FALSE)


p
# Saving at png
ggsave(p, file="circular_plot_just_heritab.png", width=20, height=20)

```

\




\



##5. Running CMS

Currently, the CMS algorithm is still not implemented in a package or a program. However, the authors offer a code to run CMS on large data sets available at GitLab (https://gitlab.pasteur.fr/statistical-genetics/runCMS) (ref paper runCMS). This pipeline, called runCMS and which encapsulates the CMS R code, is a 3-script code –two R scripts and one Python script– which pre-processes and pre-filters the data, runs CMS and summarizes results in tables and plots.

* *Script 1*. The first script was used to standardize all variables and pre-filter candidate covariates (urine and serum metabolomic data) before applying CMS. The covariates that were filtered out were:
    + (i) those that explained more than 70% of the outcome variance based on pairwise correlation between the outcome and the candidate covariates,
    + (ii) those that were hierarchical parent of the outcome under study or vice versa, as well as those metabolites that were measured in the two matrices (serum and urine),
    + (iii), finally, those covariates excluded based on AIC (Akaike information criteria) to reduce the number of candidate metabolites used as input of CMS to 30.

* *Script 2*. The second script ran the already published CMS code (17), which computes linear regression models under the assumption of an additive genetic model after selecting –if any– the correlated covariates that will be included in the model, apart from the user-indicated confounding variables. In this case, all models were adjusted by age, sex, the 20 first principal components (PCs) and the urine sampling type, which refers to the type of urine sample (night only, morning only or pooled sample).

* *Script 3*. Lastly, the third script parsed the results to plots, as well as, tables in which results were summarized by significant SNPs and by loci. These loci corresponded to approximately independent linkage-disequilibrium (LD) blocks based on a recombination map (32). However, this recombination map did not include chromosome X nor PAR1 and PAR2, so blocks representing these loci were manually added. Chromosome X was divided in blocks of 2 mega base pairs (Mb). Each pseudoautosomal region was represented as a locus.


\



###5.1. Modifications made to the CMS scripts


\

The runCMS pipeline offers the code used by the authors to run their analysis. Therefore, some modifications needed to be carried out in order to adapt the script to our analysis and the cluster used. 


* *Script 1* consists in an R code (`Script1_data_preparation.R`). This script was run without any modification.

* *Script 2* is a SLURM batch script (`Script2_launch_analysis_SLURM.sh`) used to launch a job array in a cluster, with one task per SNP block. This script was adapted to the cluster used by modifying the modules loading and the memory requested, as well as the output and error log directories. Once the job array was launched, each job called a Python script (`Script2.1_create_data_file.py`) which ran CMS on each SNP block, by calling an R script (`Script2.2_run_CMS.R`), and wrote results in one file per block, by calling another R script (`Script2.3_CMS.R`).

* *Script 3* is a Python script (`Script3_results_analysis.py`) which parses the results to build plots and summary tables. This script requires the `BIM` file as input, in order to include SNP-related information (chromosome, position, minor allele, etc.) to the summary tables. However, the MAF is not included in any of these tables. This is why the script was modified so that the MAF was reported in these summary tables. More concretely, the modification was done in file `Script3_functions.py`, in the `compile_results` and `significant_snps` functions. In addition, this script summarizes results by loci which correspond to approximately independent LD blocks based on a recombination map (ref map) (`regions.bed`). However, this map only considers chromosomes 1 to 22. This is why it was modified so that it included chromosome X and PAR1 and PAR2:

    + Each pseudoautosomal region was considered as a locus, so two loci were added each one spanning the length of one pseudoautosomal region.
    + No results could be found in the literature regarding independent LD blocks or recombination pattern in chromosome X. For this reason, the X chromosome was divided randomly into regions of 2 Mb, which resulted in a total of 79 loci.

    After modification of the `regions.bed` file, *Script 3* was adapted to consider the newly incorporated loci. Modifications were made in file `Script3_functions.py`, in the `fill_regions`, `quadrant_plot` and `global_quadrant_plot` functions.


The resulting scripts and `regions.bed` file after modification were the ones used to carry out our analysis. These files, together with the rest of unmodified scripts used to run CMS, can be found at: https://github.com/beacalvo/FMP/tree/master/runCMS.



\


###5.2. Computing the effective number of tests (ENT)


In order to account for all variants and all metabolites tested, the p-value threshold used to determine significant associations was calculated by dividing the standard genome-wide significance threshold of 5 x 10-8 by the ENT. The ENT is the virtual number of independent tests across the real number of tests performed and it is computed by taking into account the high degree of correlation between metabolites levels. This way, by using the ENT to correct the p-value threshold, overcorrection for multiple testing is prevented (ref).

The R code used to estimate the ENT by this method is the following (ref):

```{r}
##############################################################################
######################### Script to compute ENT ##############################
##############################################################################
#
# 12/05/2019
# Beatriz Calvo


##############################################################################
# ---- Computing ENT

urine <- read.table("phenotypes_urine.txt", header=T)

TEF<-function(data){
  library(lsr)
  
  a1<-99
  
  ### Correlation Matrix 
  for (i in 1:dim(data)[2]) {
    ex_i<-colnames(data[i])   
    ty_i <- class(data[,i])
    for (j in 1:dim(data)[2]) {
      ex_j<-colnames(data[j])    
      ty_j <- class(data[,j])
      if(ty_i == "numeric" & ty_j == "numeric") {
        a<-cor(x = data[ , c(ex_i, ex_j)])[1, 2]
      } else if(ty_i == "factor" & ty_j == "factor") {
        vi2<-as.numeric(data[,i])
        vj2<-as.numeric(data[,j])
        if (cor(vi2,vj2)>0){
          a<-cramersV(x = table(data[ , c(ex_i, ex_j)]))
        }
        else  if (cor(vi2,vj2)<0){
          a<-(-cramersV(x = table(data[ , c(ex_i, ex_j)])))
        }  
      } else {
        vi2<-as.numeric(data[,i])
        vj2<-as.numeric(data[,j])
        fm <- paste(ex_i, "~", ex_j)
        if(ty_i == "factor") {
          fm <- paste(ex_j, "~", ex_i)
        }
        fm <- lm(formula = fm, data = data[ , c(ex_i, ex_j)])
        if  (cor(vi2,vj2)>0){
          a<-sqrt(summary(fm)$r.squared)
        } else  if  (cor(vi2,vj2)<0){
          a<-(-sqrt(summary(fm)$r.squared))
        }
      }
      a1<-cbind(a1,a)
    }
    #a1<-cbind(a1,a)
  }
  
  a2<-matrix(a1[-1],nrow=dim(data)[2],ncol=dim(data)[2])
  
  colnames(a2) <- colnames(data)
  rownames(a2) <- colnames(data)
  
  # TEF outside rexposome
  M <- ncol(a2)
  lambdas <- eigen(a2)$values
  Vobs <- sum(((lambdas - 1)^2)) / (M - 1)
  Meff <- M - sum((lambdas>1)*(lambdas-1))
  alpha_corrected <- 1 - (1 - 0.05)^(1 / Meff)
  return(c(Meff,alpha_corrected))
}


res <- TEF(urine[,203:246])

5e-8/res[1]
# [1] 1.522778e-09


```

\



###5.3. Selecting confounding variables

\

All models in CMS were adjusted by age, sex, the 20 first principal components (PCs) and the urine sampling type, which refers to the type of urine sample (night only, morning only or pooled sample). In order to select these variables as confounding, correlation of the available variables and metabolite levels was tested so as to identify those variables explaining part of the metabolite variability. The ones explaining more phenotypic variability were the ones included in the model, in order to decrease metabolic variability and, thus, reduce bias such as the one due to batch effect.

Although the cohort variable was statistically significantly associated to metabolite levels (adjusted p-value < 0.05 for 39 of the 44 metabolites), it was decided to adjust the model by the 20 first PCs since there was a high collinearity between cohort and PCs (mean adjusted r2 = 0.6781519, median = 0.8887265) and because it was considered that the PCs better capture undesired structures in the data which can lead to false associations (the 20 first PCs explained 46.2% of the variability).


```{R}
##############################################################################
################### Script to select confounding variables ###################
##############################################################################
#
# 13/04/2019
# Beatriz Calvo

# ---- Testing the existance of correlation between batch variables and 
#      metabolite levels

load("dummy_and_phenotypes_file_workspace.RData")
cov <- pdata_final_metadata_EUR

# Correlation between urine metabolite levels and Run Order variable (batch)
urine_RunOrder <- NULL
urine_RunOrder <- as.list(urine_RunOrder)
for (i in 178:221) {
  res <- lm(expres_helixID[,i]~ cov$RunOrder.uri)
  urine_RunOrder[[i]] <- data.frame("Pval" = summary(res)$coefficients[2,4],
                                    "adj.r.squared" = summary(res)$adj.r.squared)
}
all.data <- do.call(rbind, urine_RunOrder)
cor_urine_RunOrder <- cbind(all.data, 
                            "P.val.adj" = p.adjust(all.data$Pval, 
                                                   method = "BH"))
write.table(cor_urine_RunOrder, file = "correlation_urine_RunOrder")
sum(cor_urine_RunOrder$P.val.adj < 0.05)
length(cor_urine_RunOrder$P.val.adj)


# Correlation between time sampling and cohort
hourvsCohort <- lm(cov$blood_sam4.ser~ cov$cohort)

# PCA of metabolites coloured by cohort
library("RColorBrewer")
pca <- prcomp(expres_helixID, scale = TRUE, center = TRUE)
color <- as.character(factor(cov$cohort, 
                             levels = c("BIB", "EDEN", "KANC", "MOBA",
                                        "RHEA","SAB"), 
                             labels = brewer.pal(n = 6, name = "RdBu")))
xl <- paste("PC1 (", round((pca$sdev[1]/sum(pca$sdev))*100, 2), "%)", sep="")
yl <- paste("PC2 (", round((pca$sdev[2]/sum(pca$sdev))*100, 2), "%)", sep="")
pdf("PCA_metabolite_cohorts.pdf")
plot(pca$x[, 1], pca$x[, 2], xlab=xl, ylab=yl, 
     main="PCA metabolite levels (serum + urine)", 
     cex.axis=0.8, cex.lab=0.8, col = color ,pch=19)
legend("bottomright", legend = c("BIB", "EDEN", "KANC", "MOBA", "RHEA","SAB"),
       col= brewer.pal(n = 6, name = "RdBu"), pch = 19)
dev.off()


# PCA of urine metabolites coloured by SamplingType (batch)
pca2 <- prcomp(expres_helixID[,178:221] , scale = TRUE, center = TRUE)
xl <- paste("PC1 (", round((pca2$sdev[1]/sum(pca2$sdev))*100,2), "%)", sep="")
yl <- paste("PC2 (", round((pca2$sdev[2]/sum(pca2$sdev))*100,2), "%)", sep="")
color <- as.character(factor(cov$Urine.SamplingType.uri, 
                             levels = c("CUX", "MUX","NUX"), 
                             labels = brewer.pal(n = 3, name = "Set2")))
pdf("PCA_metabolite_urine_SamplingType.pdf")
plot(pca2$x[, 1], pca2$x[, 2], xlab=xl, ylab=yl, 
     main="PCA urine metabolite levels by Sampling type", 
     cex.axis=0.8, cex.lab=0.8, col = color, pch = 19)
legend("bottomright", legend = c("CUX", "MUX","NUX"), 
       fill= brewer.pal(n = 3, name = "Set2"))

res.aov.SamplingType <- aov(pca2$x[,1]~cov$Urine.SamplingType.uri)
summary(res.aov.SamplingType)

res.aov.SamplingType2 <- aov(pca2$x[,2]~as.factor(cov$Urine.SamplingType.uri))
summary(res.aov.SamplingType2)

# ---- Testing the existance of correlation between cohort and PCs and 
#      metabolite levels

# Association between urine levels and cohort
p_val_all_coh <- NULL
for (m in 178:221) {
  p_val_coh <- summary(aov(exprs_helixID[,m]~cov$cohort.ser))[[1]][["Pr(>F)"]][1]
  p_val_all_coh <- c(p_val_all_coh,p_val_coh)
}

p_val_all_coh <- p.adjust(p_val_all_coh, method = "BH")
sum(p_val_all_coh < 0.05) 
# 39 of 44 metabolites are statistically significantly associated with cohort

# Association between urine levels and 20 first PCs
p_val_all_PC <- NULL
for (n in 178:221) {
  p_val_PC <- summary(lm(exprs_helixID[,n]~cov$PC1+cov$PC2+cov$PC3+cov$PC4+
                           cov$PC5+cov$PC6+cov$PC7+cov$PC8+cov$PC9+cov$PC10+
                           cov$PC11+cov$PC12+cov$PC13+cov$PC14+cov$PC15+
                           cov$PC16+cov$PC17+cov$PC18+cov$PC19+
                           cov$PC20))$coefficients[,4]
  p_val_all_PC <- rbind(p_val_all_PC,p_val_PC)
}

p_val_all_PC_adj <- apply(p_val_all_PC, 2,
                          function(x) p.adjust(x, method = "BH"))
sum(p_val_all_PC < 0.05) 
# 87 of 880 metabolite-PC associations are statistically significant


# Association between cohort variable and 20 first PCs

PCAvsCohort_res <- matrix(nrow = 20, ncol = 2)
colnames(PCAvsCohort_res) <- c("Adj_r2","P-value")
for(i in 1:20) {
  PCAvsCohort <- lm(cov[,i+6]~ cov$cohort.ser)
  PCAvsCohort_res[i,] <- c(summary(PCAvsCohort)$adj.r.squared,
                           summary(PCAvsCohort)$coefficients[2,4])
}

```


\



###5.4. Code used to run CMS

\

As mentioned in Section 2.6., three different analysis were run. Two of them were one positive control and one negative control, in which only genetic variants located in two different loci (FADS and AGXT2) of the genome were tested. The third, and most relevant analysis, tested the association between the 44 urine metabolite levels and the whole dataset of genotype data. These three analysis were run very similarly: the same phenotypes and summary files were used, only the file containing the genotype data differed.


`runCMS` pipeline is composed of 3 main scripts -as stated in Section 2.6.-:

* *Script 1* was run locally as an R script. The arguments used were the folder path for pipeline, the folder for analysis, the phenotypes file (containing confounding variables, as well as urine and serum metabolite levels), the phenotypes summary file, the number of covariates (urine and serum metabolites) selected for each outcome (urine metabolites) and the threshold on outcome variance explained by covariates.

* *Script 2* was run in the cluster, which used SLURM as job scheduler. As previously mentioned, *Script 2* launches a job array in which each jobs runs CMS for a block of SNPs. The arguments used were: the folder path for pipeline, the folder for analysis, the genotypes file (in `.raw` format), the phenotypes summary file, the total number of SNPs analysed and the number of SNPs per block.

* *Script 3* was run locally as a Python script. The arguments used to run it were: the folder path for pipeline, the folder for analysis, the genotypes file (`BIM` file), the phenotypes summary file, the number of blocks of SNPs (i.e. the number of jobs in the array) and the significance threshold.



The following code shows how these scripts were called and which arguments were used, in each of the three analysis that were run.

\



####5.4.1. Positive control (AGXT2 locus)

\

```{bash}

# ---- Script 1

#Folder path for pipeline
arg1=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/runCMS-master

#Folder for analysis
arg2=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/FADS_runCMS/urine/log2_typification

#Input phenotypes file
arg3=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/input_files/phenotype_data_in_log/phenotypes_urine.txt

#Input summary file
arg4=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/input_files/summary_urine.csv

#Covariates number
arg5=30

#Threshold on outcome variance explained by covariates
arg6=0.7

Rscript /home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/runCMS-master/Script1_data_preparation.R $arg1 $arg2 $arg3 $arg4 $arg5 $arg6


# ---- Script 2

#Folder path for pipeline
arg1=/homes/users/bcalvo/CMS/runCMS

#Folder for analysis
arg2=/homes/users/bcalvo/CMS/AGXT2/urine/log2_typification

#Genotypes file
arg3=/homes/users/bcalvo/CMS/AGXT2/HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05_AGXT2.raw

#Input summary file
arg4=/homes/users/bcalvo/CMS/input_data/summary_urine.csv

#SNP number
arg5=1065

#Number of SNPs per block
arg6=22

sbatch --array=1-50 /homes/users/bcalvo/CMS/runCMS/Script2_launch_analysis_SLURM.sh $arg1 $arg2 $arg3 $arg4 $arg5 $arg6


# ---- Script 3

#Folder path for pipeline
arg1=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/example_test_runCMS/runCMS

#Folder for analysis
arg2=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/AGXT2/urine/log2_typification

#Genotypes file
arg3=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/AGXT2/HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05_AGXT2_MAF.bim

#Input summary file
arg4=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/input_files/summary_urine.csv

#Blocks number
arg5=50


#Significance threshold

arg6=0.00000000056 ## 5.594062e-10

python3 /home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/example_test_runCMS/runCMS/Script3_results_analysis.py $arg1 $arg2 $arg3 $arg4 $arg5 $arg6
```
\




####5.4.2. Negative control (FADS locus)


```{bash}

# ---- Script 1

#Folder path for pipeline
arg1=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/runCMS-master

#Folder for analysis
arg2=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/FADS_runCMS/urine/log2_typification

#Input phenotypes file
arg3=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/input_files/phenotype_data_in_log/phenotypes_urine.txt

#Input summary file
arg4=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/input_files/summary_urine.csv

#Covariates number
arg5=30

#Threshold on outcome variance explained by covariates
arg6=0.7

Rscript /home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/runCMS-master/Script1_data_preparation.R $arg1 $arg2 $arg3 $arg4 $arg5 $arg6



# ---- Script 2

#Folder path for pipeline
arg1=/homes/users/bcalvo/CMS/runCMS

#Folder for analysis
arg2=/homes/users/bcalvo/CMS/data_FADS/urine/log2_typification

#Genotypes file
arg3=/homes/users/bcalvo/CMS/data_FADS/HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05_FADS.raw

#Input summary file
arg4=/homes/users/bcalvo/CMS/input_data/summary_urine.csv

#SNP number
arg5=980

#Number of SNPs per block
arg6=20

sbatch --array=1-50 /homes/users/bcalvo/CMS/runCMS/Script2_launch_analysis_SLURM.sh $arg1 $arg2 $arg3 $arg4 $arg5 $arg6



# ---- Script 3

arg1=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/example_test_runCMS/runCMS

#Folder for analysis
arg2=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/FADS_runCMS/urine/log2_typification

#Genotypes file
arg3=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/input_files/HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05_FADS_MAF.bim

#Input summary file
arg4=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/input_files/summary_urine.csv

#Blocks number
arg5=50

#Significance threshold

arg6=0.00000000056 ## 5.594062e-10

python3 /home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/example_test_runCMS/runCMS/Script3_results_analysis.py $arg1 $arg2 $arg3 $arg4 $arg5 $arg6

```
\




####5.4.3. Whole genome analysis



```{bash}
# ---- Script 1

# Folder path for pipeline
arg1=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/runCMS-master

# Folder for analysis
arg2=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/urine_genotyped/urine_genotyped_MAF0.05_PC_adjusted

# Input phenotypes file
arg3=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/input_files/phenotype_data_in_log_PCs/phenotypes_urine.txt

# Input summary file
arg4=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/input_files/summary_urine.csv

# Covariates number
arg5=30

# Threshold on outcome variance explained by covariates
arg6=0.7

Rscript /home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/runCMS-master/Script1_data_preparation.R $arg1 $arg2 $arg3 $arg4 $arg5 $arg6



# ---- Script 2

# Folder path for pipeline
arg1=/homes/users/bcalvo/CMS/runCMS_backup

# Folder for analysis
arg2=/homes/users/bcalvo/CMS/urine_genotyped/urine_genotyped_MAF0.05_PC_adjusted

# Genotypes file
arg3=/homes/users/bcalvo/shared_data/GWAS_data/MAF_0.05/HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05.raw

# Input summary file
arg4=/homes/users/bcalvo/CMS/input_data/summary_urine_PCs.csv

# SNP number
arg5=283704

# Number of SNPs per block
arg6=1000

sbatch --array=1-284 /homes/users/bcalvo/CMS/runCMS_backup/Script2_launch_analysis_SLURM.sh $arg1 $arg2 $arg3 $arg4 $arg5 $arg6




# ---- Script 3

# Folder path for pipeline
arg1=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/example_test_runCMS/runCMS_new

# Folder for analysis
arg2=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/urine_genotyped/urine_genotyped_MAF0.05_PC_adjusted
  
# Genotypes file
arg3=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/urine_genotyped/HELIX_GWAS_FINAL_genotyped_XYchr_without_Y_MT_MAF0.05_MAF.bim

# Input summary file
arg4=/home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/input_files/summary_urine_PCs.csv

# Blocks number
arg5=284

# Significance threshold

arg6=0.000000001522778    # 1.522778e-09

python3 /home/isglobal.lan/bcalvo/data/WS_HELIX/HELIX_analyses/metabQLTs_BC/CMS_algorithm/runCMS_approach/example_test_runCMS/runCMS_new/Script3_results_analysis.py $arg1 $arg2 $arg3 $arg4 $arg5 $arg6


```

\



##6. Comparison of the identified metabQTLs with urinary metabQTLs in adults


Comparison of our results with findings from other studies with adults was done by two approaches: SNP-based and locus-based. In both cases, a reference dataset containing adult urinary metabQTLs identified in other studies was built for comparison. Locus-based comparison was carried out by comparing the LD block number to which the locus corresponded to, instead of directly comparing the locus in which the SNP was found. The corresponding LD block number was addded for each association from the created reference dataset based on the position from the SNP. Our results already had an LD block number for each SNP.


```{r}

##############################################################################
############# Comparison of our results with results in adults ###############
##############################################################################

##############################################################################
# ---- Combining results of urine papers ----

# -- Suhre et al (2011)
suhre <- read.table("/significant_snps_paper_Suhre.txt",
                    sep = "\t", header = TRUE)

# Selecting only those associations that are not with ratios
suhre <- suhre[suhre$Nominator == "ONE",]
suhre_final <- suhre

# Converting alleles to + strand
suhre_final$Allele.A[suhre$Allele.A == "A" & suhre$Strand == "-"] <- "T"
suhre_final$Allele.A[suhre$Allele.A == "T" & suhre$Strand == "-"] <- "A"
suhre_final$Allele.A[suhre$Allele.A == "C" & suhre$Strand == "-"] <- "G"
suhre_final$Allele.A[suhre$Allele.A == "G" & suhre$Strand == "-"] <- "C"

suhre_final$Allele.B[suhre$Allele.B == "A" & suhre$Strand == "-"] <- "T"
suhre_final$Allele.B[suhre$Allele.B == "T" & suhre$Strand == "-"] <- "A"
suhre_final$Allele.B[suhre$Allele.B == "C" & suhre$Strand == "-"] <- "G"
suhre_final$Allele.B[suhre$Allele.B == "G" & suhre$Strand == "-"] <- "C"

# Final dataset Suhre
suhre_final_2 <- suhre_final[,c("SNP.ID","CHR", "BP", "Enumerator", "BETA",
                                "P","Allele.A","Allele.B")]

alleles <- paste(suhre_final_2$Allele.A, suhre_final_2$Allele.B, sep = "/")

suhre_final_3 <- cbind(suhre_final_2[,c(1:6)], alleles)
write.table(suhre_final_3, 
            file = "../urine_papers_results/urine_results_Suhre_etal_2011.txt",
            row.names = FALSE, quote = FALSE, sep = "\t")

# -- Rueedi et al (2014): directly copied into the excel file

# -- Raffler et al (2015): used the data in The GWAS metabolome database
#    for this paper (single metabolites and targeted and urine (SHIP))

raffle <- read.table("results_single_targeted_for_gwasserver_download.txt",
                     sep = "\t", header = TRUE)
raffle_final <- raffle[raffle$P < 5E-8,]

# Adding the HMDB ID
IDs <- read.table("IDs_equivalences_GWAS_metab_database.txt", sep = "\t",
                  header = TRUE)

IDs_simplifyed <- IDs[,c(1,2,4)]

raffle_final_HMDBid <- merge(raffle_final, IDs_simplifyed, by.x = "METID",
                             by.y = "Chenomx")

raffle_final_HMDBid <- raffle_final_HMDBid[,c("SNP", "CHR", "POS", "MET", 
                                              "BETA", "P", "EA", "HMDB")]

write.table(raffle_final_HMDBid, 
            file = "results_single_targeted_pvalue_filtered.txt", 
            row.names = FALSE, quote = FALSE, sep = "\t")
```


```{python}

##############################################################################
# ---- Adding LD block number to reference dataset metabQTLs

import pandas as pd
import numpy as np
import re

regions = pd.read_csv('runCMS-master/others/regions.bed', sep='\t')
df = pd.read_csv('Results_all_papers_urine_combined.txt', sep ='\t')
reg = pd.DataFrame(np.zeros(df.shape[0], dtype = int))

for r in range(0, 1706):
    left = regions[' start '][r]    
    right = regions[' stop'][r]    
    chrnum = [int(i) for i in re.findall('\d+', regions['chr '][r])]   
    ind = np.where((df['CHR'] == chrnum) & (df['POS'] >= str(left) ) & (df['POS'] <= str(right) ))    
    reg.iloc[ind] = r + 1

df['Region'] = reg
df.to_csv(r'./urine_all_studies_with_regions.csv',sep='\t', index=False, header=False)

```


```{r}
##############################################################################
# ---- Comparison of our results with results in adults from other studies


# -- Defining function that will be used to find common SNP-metabolite 
#    associations

# By-SNP

combine_results_by_snp <- function(results_snp,db) {
  
  # "results": our results // "db": results of other studies
  
  setkey(db, "SNP.ID_db")
  results_combined <- NULL
  results_combined <- as.data.frame(results_combined)
  met_combined <- NULL
  met_combined <- as.data.frame(met_combined)
  
  for (i in 1:nrow(results)) {
    snp_db <- as.data.frame(db[.(results$SNP[i]),])
    snp_db <- unique(snp_db)  # In "db" there are repeated rows
    
    if (is.na(snp_db$POS_db)) { # SNP not found in other results
      met_combined <- cbind(results[i,],"SNP not found in database",rep(NA,13))              
      names(met_combined) <- c(colnames(results), 
                               colnames(snp_db),
                               "Other_metabolite_db")
      results_combined <- rbind(results_combined, met_combined)
      met_combined <- NULL
      print(i)
    }
    
    else { 
      mets <- unlist(strsplit(as.character(results$HMDB[i]), ","))
      
      if (is.na(mets)) {
        met_combined <- cbind(results[i,], 
                              t(c("Missing metabolite ID in results", 
                                  rep(NA,13))))
        names(met_combined) <- c(colnames(results), 
                                 colnames(snp_db), 
                                 "Other_metabolite_db")
        results_combined <- rbind(results_combined, met_combined)
        met_combined <- NULL
        
      }
      
      else {
        
        for (met in mets) {
          index <- grep(met, snp_db$HMDB_db)
          
          if (length(index) == 0) {
            met_combined <- cbind(results[i,], snp_db[,1:3], "Other", 
                                                   snp_db[,5:13], 
                                                   snp_db$Metabolite_db)
            met_combined[j,17] <- as.character(snp_db[,"CHR_db"])
            met_combined[j,21] <- as.character(snp_db[,"P_db"])
            met_combined[j,24] <- as.character(snp_db[,"Region_db"])
            
          }
          
          else if (length(index) == 1) {
            met_combined <- cbind(results[i,], snp_db[index,], NA)
            met_combined[j,17] <- as.character(snp_db[index,"CHR_db"])
            met_combined[j,21] <- as.character(snp_db[index,"P_db"])
            met_combined[j,24] <- as.character(snp_db[index,"Region_db"])
          }
          
          else if (length(index) > 1) {
            for (j in 1:length(index)) {
              met_combined[j,1:(ncol(db)+ncol(results)+1)] <- as.data.frame(
                cbind(results[i,], snp_db[index[j],], NA))
              met_combined[j,1] <- as.character(results[i,1])
              met_combined[j,17] <- as.character(snp_db[index[j],"CHR_db"])
              met_combined[j,21] <- as.character(snp_db[index[j],"P_db"])
              met_combined[j,24] <- as.character(snp_db[index[j],"Region_db"])
            }
            
          }      
          names(met_combined) <- c(colnames(results), 
                                   colnames(snp_db), 
                                   "Other_metabolite_db")


          results_combined <- rbind(results_combined, as.data.frame(met_combined))
          met_combined <- NULL
          met_combined <- as.data.frame(met_combined)
          print(i)
        }
      }
    }    
  }
  
  return(results_combined)

}


# First, the column names of the data frame with the results of other studies 
# need to be changed so that they are differ from the column names of the
# data frame with our results


library(data.table)
db <- fread("urine_papers_results/Results_all_papers_urine_combined.txt", 
            header = T)

colnames(db) <- c("SNP.ID_db", "CHR_db", "POS_db", "Metabolite_db", "BETA_db",
                  "P_db", "Alleles_db", "HMDB_db", "Region_db", "MAF_db", 
                  "Author_db", "EA_db", "NEA_db")

results_snp <- read.table("summary_significant_snps_HMDB.txt", header = T)

results_combined_snp <- combine_results_by_snp(results_snp,db)
results_combined_snp <- results_combined_snp[!is.na(results_combined_snp$
                                                      Phenotype), ]


write.table(results_combined_snp, file= ".results_combined_snp_MAF0.05_.txt",
            col.names = T, quote = F,sep = "\t", row.names = F)


# By region

combine_results_by_region <- function(results_region,db) {
  
  # "results": our results // "db": results of other studies
  
  setkey(db, "Region_db")
  results_combined <- NULL
  results_combined <- as.data.frame(results_combined)
  met_combined <- NULL
  met_combined <- as.data.frame(met_combined)
  
  for (i in 1:nrow(results_region)) {
    region_db <- as.data.frame(db[.(results_region$Region[i]),])
    region_db <- unique(region_db)  # In "db" there are repeated rows
    
    if (is.na(region_db$POS_db)) { # Region not found in other results
      met_combined <- cbind(results_region[i,], "Region not found in database", 
                            rep(NA,13))
      names(met_combined) <- c(colnames(results_region), 
                               colnames(region_db),
                               "Other_metabolite_db",
                               "Number_sign_SNPs_in_region_db")
      results_combined <- rbind(results_combined, met_combined)
      met_combined <- NULL
      print(i)
    }
    
    else { 
      mets <- unlist(strsplit(as.character(results_region$HMDB[i]), ","))
      
      if (is.na(mets)) {
        met_combined <- cbind(results_region[i,],
                              t(c("Missing metabolite ID in results", 
                                                      rep(NA,14))))
        names(met_combined) <- c(colnames(results_region), 
                                 colnames(region_db), 
                                 "Other_metabolite_db",
                                 "Number_sign_SNPs_in_region_db")
        results_combined <- rbind(results_combined, met_combined)
        met_combined <- NULL
        
      }
      
      else {
        
        for (met in mets) {
          index <- grep(met, region_db$HMDB_db)
          
          if (length(index) == 0) {
            met_combined <- cbind(results_region[i,], region_db[,1:3], "Other", 
                                  region_db[,5:13], 
                                  region_db$Metabolite_db)
            met_combined[j,17] <- as.character(region_db[,"CHR_db"])
            met_combined[j,21] <- as.character(region_db[,"P_db"])
            met_combined[j,24] <- as.character(region_db[,"Region_db"])
            
          }
          
          else {
            met_combined <- cbind(results_region[i,], region_db[index[1],], 
                                  NA, length(index))
            met_combined[j,17] <- as.character(region_db[index[1],"CHR_db"])
            met_combined[j,21] <- as.character(region_db[index[1],"P_db"])
            met_combined[j,24] <- as.character(region_db[index[1],"Region_db"])
            met_combined[j,30] <- as.character(length(index))
          }
          
          names(met_combined) <- c(colnames(results_region), 
                                   colnames(region_db), 
                                   "Other_metabolite_db",
                                   "Number_sign_SNPs_in_region_db")
          
          results_combined <- rbind(results_combined, 
                                    as.data.frame(met_combined))
          met_combined <- NULL
          met_combined <- as.data.frame(met_combined)
          print(i)
        }
      }
    }    
  }
  
  return(results_combined)
  
}


results_region <- read.table("summary_significant_regions_HMDB.txt", header = T)
results_combined_region_2 <- combine_results_by_region(results_region,db)
results_combined_region <- results_combined_region[!is.na(results_combined_region$Phenotype), ]

write.table(results_combined_region, file= "../results_combined_region_MAF0.05.txt", 
            col.names = T, quote = F,sep = "\t", row.names = F)
write.table(results_combined_region_2, file= "../results_combined_region_MAF0.05_2.txt", 
            col.names = T, quote = F,sep = "\t", row.names = F)

```

\



##6. GxE interaction analysis



For statistically significant locus-metabolite associations, where the metabolite had previously been related to a dietary factor, GxE interactions were tested. Standard linear regression models (`lm()`) were used under the assumption of an additive genetic factor interacting with a dietary factor treated in tertiles. 


```{r}

# ---- Creating dataset with dietary variables to be used

expos <- expos(exppostnatal_raw)

expos_short <- cbind(helixID = sampleNames(exppostnatal_raw), 
                     meat = expos$hs_total_meat_Ter, 
                     beverages = expos$hs_beverages_Ter, 
                     dairy = expos$hs_dairy_Ter, 
                     fish = expos$hs_total_fish_Ter)
	
pNames <- phenotypeNames(exppostnatal_raw)

helixID_sampleID <- cbind(helixID=pdata$HelixID, sampleID= pdata$SampleID,
                          obesity = pdata$hs_bmicat_None)

expos_helixID <- merge(helixID_sampleID, expos_short, by.x = "sampleID",
                       by.y = "helixID")
expos_helixID <- expos_helixID[,-1]
expos_helixID <- expos_helixID[complete.cases(expos_helixID),]

# Creating dummy variables from dietary intake frequency variables in tertiles
obesity <- dummy_cols(expos_helixID$obesity, remove_first_dummy = TRUE)
meat <- dummy_cols(expos_helixID$meat, remove_first_dummy = TRUE)      
beverages <- dummy_cols(expos_helixID$beverages, remove_first_dummy = TRUE)
dairy <- dummy_cols(expos_helixID$dairy, remove_first_dummy = TRUE)        
fish <- dummy_cols(expos_helixID$fish, remove_first_dummy = TRUE)

colnames(obesity) <- gsub(".","obesity_",colnames(obesity), fixed=TRUE)
colnames(meat) <- gsub(".","meat_",colnames(meat), fixed=TRUE)
colnames(beverages) <- gsub(".","beverages_",colnames(beverages), fixed=TRUE)
colnames(dairy) <- gsub(".","dairy_",colnames(dairy), fixed=TRUE)
colnames(fish) <- gsub(".","fish_",colnames(fish), fixed=TRUE)

expos_helixID_dummies <- cbind(helixID  = expos_helixID$helixID, obesity[,-1],
                               meat[,-1], beverages[,-1],dairy[,-1],fish[,-1])

# Merging dietary intake frequency dummy variables with genotype data and confounding variables
met_exp <- merge(phenotypes_file_urine2, expos_helixID_dummies,
                 by.x = "row.names", by.y = "helixID")
met_exp_gen <- merge(met_exp, gen, by.x = "Row.names", by.y = "IID")


# Example of computation of one GxE model, in this case interaction between meat intake and SNP rs12576623 for taurine
taurine_meat <- lm(Taurine.urine~ rs12576623_C*meat_data_3+
                     rs12576623_C*meat_data_2+sex.data_male+age_sample_years+
                     sample_type.data_CUX+sample_type.data_MUX+PC1+PC2+PC3+
                     PC4+PC5+PC6+PC7+PC8+PC9+PC10+PC11+PC12+PC13+PC14+PC15+
                     PC16+PC17+PC18+PC19+PC20, data = met_exp_gen)

# Null model
taurine_meat_null <- lm(Taurine.urine~ rs12576623_C + meat_data_3+
                          meat_data_2+sex.data_male+age_sample_years+
                          sample_type.data_CUX+sample_type.data_MUX+PC1+PC2+
                          PC3+PC4+PC5+PC6+PC7+PC8+PC9+PC10+PC11+PC12+PC13+
                          PC14+PC15+PC16+PC17+PC18+PC19+PC20,
                        data = met_exp_gen)

# Comparison of models with ANOVA
anova(taurine_meat_null,taurine_meat)

```








